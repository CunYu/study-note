### 概述

CMS收集器，Concurrent Mark Sweep，其是作用于老年代的并行垃圾收集器，其采用了标记-清除算法。

CMS收集器注重GC停顿时间，适用于交互多的应用。

### 回收步骤

##### 初始标记

CMS initial mark

该步骤会发生GC停顿，其标记GC Roots能直接关联的对象，耗时短。

##### 并发标记

CMS concurrent mark

该步骤会和用户程序并发运行，其会进行GC Roots Tracing操作。

##### 重新标记

CMS remark

该步骤会发生GC停顿，由于并发标记会和用户程序并发运行，所以该步骤是为了修正并发标记步骤期间运行导致的变动，对一些对象进行重新标记操作。

该步骤耗时要比初始标记的耗时长，但是远远小于并发标记的耗时。

##### 并发清除

CMS concurrent sweep

并行执行清除操作，该步骤会和用户程序并发运行。

### 优缺点

##### 优点

CMS收集器的停顿时间很短，在整个回收过程中，其只有初始标记和重新标记时会发生停顿，其他时间并不会发生GC停顿。

##### 缺点

* CPU敏感

因为并发标记和并发清除期间GC操作会和用户程序同时运行，CMS默认GC操作线程数为（CPU数量+3）/4，所以如果CPU数量比较少，用户程序并发标记和并发清除期间效率会下降很多。

* 无法处理浮动垃圾

因为CMS在并发清除阶段，用户程序还在运行，所以其会产生垃圾，这些垃圾本次GC过程中是无法回收的，只能交给下次GC回收，这些垃圾成为浮动垃圾。

由于CMS收集器GC期间，用户程序可以继续运行，所以CMS收集器需要为运行的程序预留空间，其无法像其他收集器那样等到垃圾快满时再回收。

触发CMS收集器GC的内存比例可通过参数配置。

* 内存碎片严重

因为CMS收集器时基于标记清除算法的，所以其会产生大量的内存碎片，分配大对象比较困难。

CMS收集器可以配置在进行Full GC时进行内存碎片的合并整理，还可以配置几次碎片不合并整理的Full GC后进行一次碎片合并整理的Full GC。

合并整理时无法并发，GC停顿时间会增长。