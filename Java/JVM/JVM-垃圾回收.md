### 概述

垃圾回收简称GC（Garbage Collection），GC会对不再使用的内存进行回收。因为程序计数器，虚拟机栈，本地方法随线程的生命周期一致，故GC针对的是堆和方法区。

### 引用类型

* 强引用

对象只要存在强引用，GC就不会进行回收。Java中，Object object = new Object()就是强引用。

* 软引用

标识有用但非必须的对象，系统发生内存溢出异常之前，会将该类对象列入回收范围并进行回收。可通过SoftReference类来实现。

* 弱引用

弱引用标识的对象在下一次垃圾回收时回收。当垃圾收集器工作时，无论内存是否足够，都会将弱引用标识的对象。可通过WeakReference类来实现。

* 虚引用

又称为幽灵引用或者幻影引用，其不会对对象的生命周期产生任何影响，当收集器准备回收被虚引用标识的对象的内存前，会将虚引用加入到与之关联的引用队列（ReferenceQueue）中。

### 判断需要回收的内存

##### 堆（对象）

###### 引用计数算法

引用计数算法会给对象分配一个引用计数器，每当有地方引用其时，计数器会加一，当引用失效时，计数器会减一，计数器为零的对象不能被使用。

引用计数算法很难处理对象互相循环引用，故Java没有使用使用引用计数算法。

###### 可达性分析算法

Java采用的算法，该算法会选择一个GC Roots对象作为起始点，然后开始搜索，搜索走过的路径称为引用链（Reference Chain）。

当对象与GC Roots之间没有引用链时，则表示该对象不可用。

在可达性分析算法分析过程中，判断一个对象是否回收，至少要经过两次标记过程，对象第一此分析过程中，与GC Roots之间没有引用链时，其会被第一次标记，如果其重写过finalize()方法，且该方法没有被调用过，该方法会被添加到F-Queue队列中，该队列中的对象会由一个低优先级的Finalizer线程去执行其finalize()方法，对象可以用该方法来自救（避免被回收）。

可作为GC Roots的对象

* 虚拟机栈中引用的对象

* 方法区类静态属性引用的对象

* 方法区中常量引用的对象

* 本地方法栈中JNI（Native方法）引用的对象

##### 方法区（废弃常量，无用类）

常量池中没有任何地方引用的常量，该常量会被回收。

虚拟机也可以对无用类进行回收，

无用类判断标准

* 该类的所有实例被回收，堆中不存在其任何实例。

* 加载该类的ClassLoader被回收。

* 该类的java.lang.Class对象没有在任何地方被引用，没有在任何地方被通过反射访问。

### 垃圾收集算法

* 标记-清除（Mark-Sweep）算法

该算法先标记所有需要回收的对象，标记结束后再统一回收标记的对象。

该算法标记和清楚的效率都不高并会产生大量不连续的内存碎片。

* 复制（Copying）算法

该算法将内存按容量分为大小相等的两块，每次只使用其中的一块，当目前使用的这块内存使用完时，其会将还存活的对象复制到另一块上并按顺序依次存放，然后把当前块内存回收，开始使用另一块内存。

复制算法效率高，但是内存代价很大。

* 标记-整理算法

该算法先标记所有需要回收的对象，标记结束后将存活的对象按顺序依次存放，然后再回收存活的对象以外的内存。

* 分代收集算法

该算法将内存划分为多块，每块根据实际情况采用合适的垃圾收集算法。

该算法为当前主流的垃圾收集算法，一般划分为青年代和老年代，青年代一般采用复制算法，老年代一般采用标记-清除或者标记-整理算法。

### 垃圾收集器

垃圾收集算法是垃圾回收的理论方法，具体的垃圾回收是由垃圾收集器实现的。

Java虚拟机规范对垃圾收集器的实现没有任何规定，不同厂商，不同版本的垃圾收集器可能会有很大的差距。