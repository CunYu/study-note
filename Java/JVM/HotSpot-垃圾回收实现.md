### 可达性分析

HotSpot使用可达性分析算法来判断需要回收的内存，枚举根结点和分析无用内存是可达性分析重要的部分。

现在应用的JVM配置的内存很大，可达性分析需要消耗很多的时间，并且可达性分析需要在内存中的引用关系不改变的情况下进行，也就是需要GC停顿（停顿所有Java执行线程），引用关系一直变化是无法进行可行性分析的，因为无法保证准确性。

HotSpot使用OopMap数据结构来记录虚拟机中的对象引用，在类加载完后和JIT编译过程中都会在特定的位置记录引用信息，这样GC时可以直接获取引用信息，减少了GC停顿的时间，上述行为也称为准确式GC，不需要在GC停顿的时候分析引用位置。

### 安全点（SafePoint）

由于OopMap的存在，使得GC回收时可以快速完成枚举根结点，但是如果每一条指令都生成对应的OopMap数据结构会需要大量的存储空间。

HotSpot只有在安全点记录Oop信息，线程也不是在所有地方都能停顿下来执行GC，其只能在安全点才能停顿执行GC，安全点的选定很关键，既不能太频繁，也不能让GC等待时间太久。

有两种方式来使所有Java执行进程在GC时停顿下来。

* 抢先式中断（Preemptive Suspension）

GC发生时，中断所有线程，如有线程中断的地方不是安全点，就恢复线程，让其执行到安全点上再中断，现在几乎没有任何虚拟机使用抢先式中断。

* 主动式中断（Voluntary Suspension）

GC发生时，会设置一个标识，每个线程执行的时候都会在安全点查询这个标识，如果发现表示为真就中断自己。

### 安全区域

HotSpot使用的是主动式中断，但是如果线程无法执行到安全点（线程处于Sleep或Blocked状态）的时候就需要用到安全区域。

安全区域是指引用关系不会发生改变的一段代码区域，在这个区域都可以GC。

当线程进入安全区域时，会把自己标识为Safe Region状态，GC不会处理处于安全区域状态的线程，当线程离开安全区域时，会先判断当前是否有GC处理，如有GC正在处理，其会等待直到GC完成收到可以安全离开安全区域的信号。

### HotSpot虚拟机垃圾收集器

<img src="./Java/JVM/image/HotSpot虚拟机垃圾收集器.png" alt="HotSpot虚拟机垃圾收集器"/>

* Serial/Serial Old 收集器

Serial收集器时最基本，最古老的收集器，其是单线程的而且在GC时必须暂停其他所有线程。

Serial收集器作用在青年代，Serial Old收集器是Serial收集器的老年代版本。

Serial收集器是串行的，采用标记复制算法，Serial Old 收集器是串行的，采用标记整理算法。

Serial收集器是虚拟机运行在Client模式下的默认青年代收集器，在单CPU环境下，其GC效率最高。

* ParNew 收集器

ParNew收集器是Serial收集器的多线程版本。

ParNew收集器作用在青年代。

ParNew收集器是并行的，采用标记复制算法。

ParNew收集器是很多虚拟机运行在Server模式下的首选青年代收集器，其可以和CMS收集器配合工作。

* Parallel Scavenge/Parallel Old 收集器

Parallel Scavenge收集器是一个注重吞吐量的收集器，吞吐量是指运行应用程序时间和运行应用程序时间加上垃圾收集时间的比值。

Parallel Scavenge收集器作用在青年代，Parallel Old收集器是Parallel Scavenge收集器的老年代版本。

Parallel Scavenge收集器是并行的，采用标记复制算法，Parallel Old 收集器是并行的，采用标记整理算法。

高吞吐量可以高效率的利用CPU，适合运算多交互少的任务，而其他收集器注重的GC停顿时间，GC停顿时间越短，交互体验越好，适合交互多运算少的任务。

* CMS（Concurrent Mark Sweep） 收集器

CMS收集器是一个注重GC停顿时间的收集器。

CMS收集器作用在青年代。

CMS收集器是并行的，采用标记清除算法。

* G1 （Garbage-First）收集器

G1收集器是当前收集器技术发展最前沿的成果之一，其兼顾吞吐量和GC停顿时间。

G1收集器可以作用于青年代和老年代。

G1收集器是并行的，采用标记整理算法。